# 数据状态管理

当随着应用的规模扩大，数据状态管理将成为程序关注的重点，承载核心。

begoina使用了一个简版的redux库`bex`来进行数据管理。

首先，来看下redux的设计:

```
                    Service
                    |  ^
                    v  |
View - ViewModel--->action--dispatch
            |               |
            |            reducers
            |               |
            getters--state--|

```

结合小程序开发的实际，我们希望可以有对象能时刻监控state的变化，将我们关注(订阅)的分支变化进行报告。
此外，我们还想使用类似计算属性的功能，可以对数据进行加工。当然，如果能结合之前建立的VMP进行延迟提交，则更为有利。

因此，我们将进行如下变化:

```
                          Service
                           |  ^
                           v  |
View---VMP---ViewModel--->action----dispatch
        |                              |
        |                          reducers
        |                              |
        WatchManager---getters--state--|

```

而这，正式`bex`的内部结构：

- bex.js  bex模块的入口，以及主要api提供者，不仅提供装载到BE上的方法，而且提供给vmp实例的方法。
- ReduxLite.js 简版的redux实现
- WatchManager.js 通过对state变化的监控，提供订阅state某个分支变化的api，并为vmp实例提供类似计算属性的在加工功能。

## 使用bex，构建数据状态树state

### 1. 建立store目录

为了便于管理和维护，我们可以在项目开发根目录中建立一个`store`目录，将对bex模块的配置放入其中。

```
其他目录
|
|-store
|   |-store.js  入口文件，配置bex
|   |-user.js   state分支文件，例如，处理用户信息的user.js
|   |
|   其他state分支文件
|
其他目录

```

### 2. 配置bex

现在以一个`store.js`为例:

```js
// store.js
import BE from '../begonia/begoina';    //导入begonia入口模块
import bex from '../begonia/bex/bex';   //导入bex的入口文件

import user from './user';      //导入分支文件user.js
import system from './system';  //导入分支文件system.js
import ui from './ui';          //导入分支文件ui.js

//将bex装载到begoina的主模块上
//装载之后,vmp实例可以获得`watch`和`unwatch`等实例方法
BE.use(bex);

//创建一个store实例
const store = bex.createStore({
    //在modules字段下，装载定义的state分支对象
    modules:{
        user,
        system,
        ui,
    }
});

//导出store实例对象
export default store;

```

此后，在小程序的主文件`app.js`，直接导入此文件即可。

```js
//app.js
import './store/store.js';

```

### 创建state分支文件

按照redux思想，当vm需要一项数据，需要先创建一个action，然后将它dispatch到一个对应的reducer，
reducer是具有修改state分支功能的纯函数，当它修改state之后，state派发自己的修改信息。

这里，类似`vuex`，我们也为`bex`建立了一个最基本的state分支文件结构:

```js
export default {
    state:{
        //本分支的state对象
    },
    getters:{
        //用于访问state分支的数据
    },
    actions:{
        //各种action函数
    },
    reducers:{
        //各个用来修改state特定分支的reducer函数
    }
}
```

这里以用户信息分支`user.js`为例，了解一下如何创建一个state分支：

```js
//user.js

/**
 * user state 相关
 */
//=====================================================
//导入bex中的相关方法
import {getters,actions} from '../begonia/bex/bex';
//导入用于远程加载用户信息的UserService
import UserService from '../services/UserService';
//=====================================================
//reducer名常量
const SET_USER = 'setUser';
const ADD_USERS = 'addUsers';
const SET_NEED_AUTH = 'setNeedAuth';
const SET_LOGIN_FAILED = 'setLoginFailed';

export default {
    //state分支对象
    state:{
        users:{},
        userId:0,
        needAuth:false,
        loginFailed:false,
    },
    //访问分支的getter方法
    getters:{
        users:state => state.users,
        userId:state => state.userId,
        needAuth:state => state.needAuth,
        loginFailed:state => state.loginFailed,
    },
    //action含糊集合
    actions:{
        /**
         * 启动登录
         */
        setupLogin({dispatch}){

            UserService.setupLogin().then(function(res){
                let user = res;
                if(!user || !user.id){
                    return;
                }
                //将用户对象加入state分支
                dispatch({
                    type:ADD_USERS,
                    payload:{
                        [user.id]:user,
                    }
                });
                //设置当前的用户id
                dispatch({
                    type:SET_USER,
                    payload:user.id,
                });
        
            }).catch(function(error){
                Log.error("In user state setupLogin,catch an error.",error);
                //设置登录失败状态
                dispatch({
                    type:SET_LOGIN_FAILED,
                    payload:true
                });
            });
        },
        /**
         * 设置用户需要进行授权的状态
         */
        setNeedAuth({dispatch},needAuth){
            dispatch({
                type:SET_NEED_AUTH,
                payload:needAuth,
            });
        }      
    },
    //修改分支的reducer函数，注意数据的不可变性
    reducers:{
        [ADD_USERS](state, action){
            state.users = Object.assign({},state.users,action.payload);
        },
        [SET_USER](state, action){
            state.userId = +action.payload;
        },
        [SET_NEED_AUTH](state, action){
            state.needAuth = action.payload;
        },
        [SET_LOGIN_FAILED](state, action){
            state.loginFailed = action.payload;
        },
    },
}

```

## 3. 在小程序页面和组件实例中，使用bex订阅关注的state分支

### 0. 导入文件

```js
import BE from '../../../begonia/begoina';
import {getters,mapActions} from '../../../begonia/bex/bex';
```

### 1. 创建VMP实例

```js
this.vmp = BE.getProxy(this);
this.watchProps();    
```

这里，我们在创建vmp实例之后，调用了一个自定义方法`watchProps()`，用来启动监听属性。


### 2. 监听属性列表

首先，声明需要监控的列表

```js
//...
watchProps(){
    this.vmp.watch(['userId','loginFailed']);
},
//...
```

如此设置之后，当监控的属性发生变化时，`userId`和`loginFailed`将会被直接使用vmp提交更新。
因此，我们是可以在vm的代码中，或者视图的wxml代码中使用这两个属性的。例如在页面实例的方法中，可以使用:

```js
//经过同步，提交之后，可以通过this.data访问
let userId  = this.data.userId;

if(this.data.loginFailed){
    //处理登录失败
}

```

很多时候，我们不仅需要监控数据的变化，还想再变化时能过进行一定的加工处理，并且还可能对程序的执行流程进行控制。
bex提供了特定的写法，支持这一需求:

```js
this.vmp.watch([
    {
        prop:'userId',
        update(value){
            //方法中的this，指向页面实例或者组件实例
            //do something for userId

            //将加工后的数据返回，就会被应用在vm.data中。如果没有处理就原样返回参数(value)，
            //或者不返回任何值(将会被认为返回undefined,默认使用原始值value)
            return userId;  
        },
    },
    {
        prop:'loginFailed',
        //可以指向其他方法
        update:this.handeLoginFailed,
    }
]);

//...
handeLoginFailed(value){
    //do something
    return value;
},
//...

```

#### 获取初始值

默认情况下，当你将一个属性加入到观察列表中后。在bex启动时，就会将state分支上的对应属性的初始值，赋给我们订阅的属性。也就是说，在bex启动时，会为订阅的属性赋值，或者调用一次属性提供的`update`函数(如果有的话)。

当你不想让订阅的属性获得初始值，想等到运行期间state发生变化时再来赋值，那么可以使用`watch`方法的第二个参数，设置为false，如下所示:

```js
this.vmp.watch([],false);
```

#### 更细粒度的控制，某一个属性不需要获取初始值

一般情况下，我们订阅的属性，都是需要获取初始值的。
而某些情况下麻烦的是，某一个属性，并不需要获取初始值，或者获取初始值会引起不符合期望的副作用。
这时，如何让bex跳过这个属性，不进行初始值赋值，而等待下次变化时才赋值呢？

我们可以使用属性对象的`initGet`属性，将它设置为false,这样这个属性就不会获得初始值。

```js
this.vmp.watch([
    {
        prop:"property1",
        initGet:false,  //不获取初始值
    },
    {
        prop:"property2",
        initGet:false,  //不获取初始值
        update(value){},
    }
]);

```

### 3. 解除监控

- 解除某一个属性的监控，直接调用`unwatch()`即可，如下所示：

```js
this.vmp.unwatch('userId');
```

- 解除某几个属性的监控

```js
this.vmp.unwatch(['userId','loginFailed']);
```

如果有设置`listener`(是指`update`方法)，不必显式解除`listener`，内部会一并解除。

## 更多用法

### 只加工，不更新视图

有一些属性，我们只想监控它的改变，但是其实在视图中并不会真正用到。而要获得每项state中值的变化，就要watch它，
这样就会最终被添加到`data`当中。因此引起了两个问题：

- state中的数据需要变化才会真正被用在视图中，把这个数据加入到vm.data中没有意义。
- 只是为了监控关键数据的变化，而并没有再视图中使用该数据。

例如，用户的`userId`，我们监控它，是因为可以通过它判断用户是否已经登录。但是在视图中，我们并不需要直接使用这个数值。
此时，因为我们监控了它，所以也会被更新到vm的`data`对象中(通过`setData`，记得吗？)。这其实是很不必要的，那么如何只监控，而不更新呢？

实际上在反应值变化的`listener`回调函数(update方法)中，还有第二个参数。是一个常量`NO_BIND`。如果你的情况符合上面2个，或者其他你不想将属性添加到vm.data中时，都可以返回这个常量。这样bex就只会向你汇报数据的变化，更新state树，而不会将它加入到vm.data中去。

代码例子:

```js
this.vmp.watch([
    {
        prop:'userId',
        update(data,no){
            //方法中的this是应用的this

            //如果不想将数据加入到vm.data中，或者不想更新vm.data中的同名属性，就返回第二个参数。
            return no;  
        },
    },    
]);

```

### 注意点：如果想要让state的一个分支属性被监控，必须设置对应的getter方法

也就是说，在state分支文件中的getters字段中，必须设置属性的getter方法.

```js
//...

//访问分支的getter方法
getters:{
    users:state => state.users,
    userId:state => state.userId,
    needAuth:state => state.needAuth,
    loginFailed:state => state.loginFailed,
},

//...

```


## 简述
VMP(View Model Proxy) 的实例是小程序页面实例或组件实例的代理对象。以它作为基础，begoina将一些相关的增强模块添加其上，从而支持小程序的运行。

## 代理提交和延迟生效

在小程序开发的过程中，需要经常提交数据修改，以使页面UI由数据驱动发生变化。

这一过程从微信小程序框架提供的`setData()`方法开始。在微信官方文档中提到，当数据变更经由`setData()`启动，会先转化为`json`数据格式，然后通过`jsBridge`提交底层原生组件进行处理。因此这一过程如果频繁发生，又或者每次提交的数据量过大，都会对小程序的性能造成影响。

VMP使用了延迟提交方式优化了这一过程。所有需要使用`setData()`进行的数据更改，现在统一使用VMP实例的`commit()`进行提交:

方法使用：
```js
//提交一项属性形式
this.vmp.commit("propertyName",value);

//或者，提交对象形式
this.vmp.commit({
    "propertyName1":value,
    "propertyName2":value2
});

```

## 创建`VMP`实例:

例如，在页面index中的例子:

```js
//引入begoina
import BE from '../../begonia/begoina';

//index.js
Page({
    data:{
        count:0,
        todoList:[
            {
                name:"举个例子",
                date:"2018-03-05"
            }
        ],
    },
    vmp:null,
    //...
    onLoad(){
        //获取VMP实例
        this.vmp = BE.getProxy(this);

        //提交修改
        this.vmp.commit("count",2);

        //可以使用对象形式提交，键名为属性名
        let list = this.data.todoList;
        this.vmp.commit({
            todoList:list.concat([
                {name:"举个对象提交的例子",date:"2018-03-05 10:44"},
                {name:"别忘了键名是属性名",date:"2018-03-05 10:45"}
            ]);
        });
    },
    //...
})
```

这样在一段时间过后（默认`100ms`），VMP内部会开始遍历列表，将提交的修改，通过调用对应页面或组件实例对象的`setData()`，交付微信小程序框架处理。

## 修改延迟时间

VMP的延迟时间是可以修改的。可以根据项目的需要权衡设置间隔的时间，总而言之不对用户体验造成很大影响又能有利于性能为好。

想要修改延迟时间，因为修改延迟时间的方法不是实例方法，所以首先需要导入VMP对象:

```js
import VMP from './begonia/ViewModelProxy';
```

然后在代码中修改时间:

```js
//...
VMP.interval = 200; //设置200毫秒间隔
```

这样，之后的延迟时间就会变成`200`毫秒。

更进一步考虑，是否可以根据用户使用的状态来动态调整延迟的时间呢？
比如，在小程序在前台运行时设置`100ms`延迟更新，而如果切换到后台(或者暂时关闭)时，再次动态修改延迟时间。

## 立即生效

在某些情况下，比如更新数据之后，马上要获取新数据中的状态。那么，这时候进行延迟提交就会造成问题。
此时，VMP的实例提供了一个立即生效的方法，可以让提交的修改立即生效。

```js
this.vmp.validateNow(); //this为小程序页面实例或者组件实例
```

立即生效方法，会引起VMP立即调用该实例的生效方法，让当前提交的修改立即传入`setData()`进行处理。

由于这种运行机制，立即生效的方法，显然应当用于特定的场景之下，而不是作为常用的处理方式。
当出现大量需要立即生效的场景时，应当再次考虑程序的结构和业务流程是否合理，并加以改善。

## 销毁

有创建，必然有销毁。何况小程序页面和组件实例本身也有声明周期。当页面关闭或者组件卸载，`onUnload`钩子函数被调用时，应当对存在的对象进行处理和清理，VMP的实例当然要包含其中。

销毁vmp实例很简单:

```js
this.vmp.destroy();
this.vmp = null;
```
完整例子:

```js
//...
onUnload(){
    if(this.vmp){
        this.vmp.destroy();
        this.vmp = null;
    }
},
//...

```

像这样调用`destroy()`就能触发VMP内部的销毁机制，不仅VMP，begonia也会对存在的这个vmp对象进行清理。
之后将属性的值标记为`null`，等待垃圾回收进行处理。

## VMP实例的代理作用

在VMP的内部，实际是分成2个部分的，当一个VMP实例被创建出来，内部还会为他分配一个不公开的对象，它承担了延迟更新的工作。
而对外导出的`vmp`实例，则仅仅是一个对象，其中挂载了一些属性，指向了内在对象的方法。这样做的目的有两点:

1. 将延迟更新和代理对象的代理功能分开，延迟功能成为独立的模块功能。
2. 导出延迟对象可作为其他增强模块方法的挂载宿主。
3. 为了以后更进一步的增强`begonia`功能作为基础。

vmp实例对象结构很简单，接近一个纯`Object`实例(`plain object`)。
当一个增强模块被加载到`begonia`中时，如果他具有为vmp实例挂载方法的能力，就会将方法加入`vmp`实例。
比如，`begonia`提供的`bex`模块加载过后，可以为`vmp`提供下列方法:

```js
//导入并加载bex模块到begonia之后

//...
this.vmp.watch();
this.vmp.unwatch();
```
并且还为vmp实例对象添加了如下属性:

```js
this.vmp.$store;
this.vmp.$actions;
this.vmp.$getters;
```

这样的设置为在小程序页面实例和组件实例中使用增强模块的功能提供了便利。

此外，begonia也提供了相应的机制，在调用`this.vmp.destroy()`进行销毁时，这些模块附加的方法属性也会被一起从vmp实例对象上清除。

## 内部对`setData()`异步的处理

如前所述，当你使用`this.vmp.commit()`提交一项数据更改时，VMP会先将它进行缓存，在时间间隔到期时，提交`setData()`更新。

而实际上，由于`setData`生效是一个异步的过程。VMP再处理时也分为2个部分的：

- 当小程序框架的`setData`没有在执行更新，VMP会将属性直接缓存在一级缓存对象`optData`中。
- 当小程序框架的`setData`正在执行更新，此时如果VMP接到了新的更新请求，则不会提交到`optData`。而是提交到二级缓存对象`cache`，
在`setData`更新完成之后，会检查`cache`中是否有等待更新的对象。如果有，这会合并到新的`optData`中，在下次生效时进行更新。




